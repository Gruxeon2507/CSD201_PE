/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Nguyen Hoang Minh
 */
public class Codeshare {
    
}
main.java
// ======= DO NOT EDIT THIS FILE ============
import java.io.*;
import java.util.*;
class Main {
   public static void main(String args[]) throws Exception {
    Graph t = new Graph();
    int choice;
    Scanner sca = new Scanner(System.in);
    System.out.println();
    System.out.println(" 1. Test f1 (1 mark)");
    System.out.println(" 2. Test f2 (1 mark)");
    System.out.println(" 3. Test f3 (1 mark)");
    System.out.println("4. Test Euler path");
    System.out.print("    Your selection (1 -> 4): ");
    choice = sca.nextInt();
    sca.nextLine();
    switch(choice) {
       case 1: t.f1();
               System.out.println("Your output:");
               Lib.viewFile("f1.txt");
               break;
       case 2: t.f2();
               System.out.println("Your output:");
               Lib.viewFile("f2.txt");
               break;
       case 3: t.f3();
               System.out.println("Your output:");
               Lib.viewFile("f3.txt");
               break;
       case 4: ArrayList lt = t.isEulerPath();
                int v0;     
                if (lt.size()>0) v0=(int) lt.get(0);
                else v0=1;
              
            if (lt.size()==0 || lt.size()==2) {
                System.out.println("Graph has Euler path");
                String fname = "f4.txt";
                File g123 = new File(fname);
                if(g123.exists()) g123.delete();
                RandomAccessFile  f = new RandomAccessFile(fname, "rw"); 
                f.writeBytes("\r\n");
                t.findEulerCycle(v0, f);
                Lib.viewFile("f4.txt"); 
            }
            else System.out.println("Not has");
            break;
       default: System.out.println("Wrong selection");
      }
     System.out.println();
   }      
 }

================================================================================
Graph.java

/* This program contains 2 parts: (1) and (2)
   YOUR TASK IS TO COMPLETE THE PART  (2)  ONLY
 */
//(1)============================================
import java.io.*;
import java.util.*;
//-------------------------------------------------------------------------------
class Graph
 {int [][] a; int n;
  char v[];
  int deg[];
  Graph()
    {v = "ABCDEFGHIJKLMNOP".toCharArray();
     deg = new int[20];
     a = new int[20][20];
     n = 0;
    }

  void loadData(int k)  //do not edit this function
   {RandomAccessFile f;int i,j,x;
    String s;StringTokenizer t;
    a = new int[20][20];
    try {
     f = new RandomAccessFile("data.txt","r");
     for(i=0;i<k;i++) f.readLine();
     s = f.readLine();s = s.trim();
     n = Integer.parseInt(s);
     for(i=0;i<n;i++)
       {s = f.readLine();s = s.trim();
        t = new StringTokenizer(s);
        for(j=0;j<n;j++) 
          {x = Integer.parseInt(t.nextToken().trim());
           a[i][j] = x;
          }
       }
     f.close();
     }
    catch(Exception e) {}

   }

  void dispAdj()
   {int i,j;
    for(i=0;i<n;i++)
     {System.out.println();
      for(j=0;j<n;j++)
        System.out.printf("%4d",a[i][j]);
     }
   }

  void fvisit(int i, RandomAccessFile f) throws Exception
   {f.writeBytes(" "+v[i]);
   }
 void fvisit2(int i, RandomAccessFile f) throws Exception
   {f.writeBytes(" "+v[i]+"("+deg(i)+")");
   }
  void breadth(boolean [] en, int i, RandomAccessFile f) throws Exception
   {Queue q = new Queue();
    int r,j;
    q.enqueue(i); en[i]=true;
    while(!q.isEmpty())
     {r = q.dequeue();
      fvisit(r,f);
      for(j=0;j<n;j++)
       {if(!en[j] && a[r][j]>0) {q.enqueue(j);en[j]=true;}
       }
     }
   }

  void breadth(int  k, RandomAccessFile f) throws Exception
   {boolean [] en = new boolean[20];
    int i;
    for(i=0;i<n;i++) en[i]=false;
    breadth(en,k,f);
    for(i=0;i<n;i++) if(!en[i]) breadth(en,i,f);
   }

 void depth(boolean [] visited,int k, RandomAccessFile f) throws Exception
   {fvisit(k,f);visited[k]=true;
    for(int i=0;i<n;i++)
      {if(!visited[i] && a[k][i]>0) depth(visited,i,f);
      }
   }
  void depth(int k, RandomAccessFile f) throws Exception
   {boolean [] visited = new boolean[20];
    int i;
    for(i=0;i<n;i++) visited[i]=false;
    depth(visited,k,f);
    for(i=0;i<n;i++) 
       if(!visited[i]) depth(visited,i,f);
   }
 void depth2(boolean [] visited,int k, RandomAccessFile f) throws Exception
   {fvisit2(k,f);visited[k]=true;
    for(int i=0;i<n;i++)
      {if(!visited[i] && a[k][i]>0) depth2(visited,i,f);
      }
   }
  void depth2(int k, RandomAccessFile f) throws Exception
   {boolean [] visited = new boolean[20];
    int i;
    for(i=0;i<n;i++) visited[i]=false;
    depth2(visited,k,f);
    for(i=0;i<n;i++) 
       if(!visited[i]) depth2(visited,i,f);
   }

 int deg(int i)
   {int s,j;
    s = 0;
    for(j=0;j<n;j++) s += a[i][j];
    s += a[i][i];
    return(s);
   }
  public void dijkstra(int from, int to) {
        int distance[] = new int[n];
        boolean[] visited = new boolean[n];
        int[] path = new int[n];
        for (int i = 0; i < n; i++) {
            distance[i] = Integer.MAX_VALUE;
            path[i] = from;
            visited[i] = false;
        }

        System.out.println("");
        distance[from] = 0;
        int sel = from;
        visited[sel] = true;
//        path[0] = from;
        for (int t = 0; t < n; t++) {
            
            for (int i = 0; i < n; i++) {
                //cac dinh lien ke cua from
                if (!visited[i] && (a[sel][i] + distance[sel] < distance[i])) {
                    distance[i] = a[sel][i] + distance[sel];
                    path[i]=sel;
                }

            }
            int min = Integer.MAX_VALUE;          
            for (int i = 0; i < n; i++) {
                if (!visited[i] && (distance[i] < min ) ) {
                    sel = i;
                    min = distance[i];
                }
            }
            visited[sel] = true;
        }

       
        int x =to;
        java.util.Stack stack = new java.util.Stack();
        while (x!=from){
            stack.push(x);            
             x=path[x];
        }
        stack.push(from);
        
        while (!stack.isEmpty()){
            x = (int) stack.pop();
            System.out.print (v [x]+" ");
        }
        System.out.println("distance = "+distance[to]);

    }

//===========================================================================
//(2)===YOU CAN EDIT OR EVEN ADD NEW FUNCTIONS IN THE FOLLOWING PART========
//===========================================================================
  void fvisitf1(int i, RandomAccessFile f) throws Exception
   {f.writeBytes(" "+v[i]+"("+deg(i)+")");
   }
 void depthf1(boolean [] visited,int k, RandomAccessFile f) throws Exception
   {fvisitf1(k,f);visited[k]=true;
    for(int i=0;i<n;i++)
      {if(!visited[i] && a[k][i]>0) depthf1(visited,i,f);
      }
   }
 void depthf1(int k, RandomAccessFile f) throws Exception
   {boolean [] visited = new boolean[20];
    int i;
    for(i=0;i<n;i++) visited[i]=false;
    depthf1(visited,k,f);
    for(i=0;i<n;i++) 
       if(!visited[i]) depthf1(visited,i,f);
   }
  void f1() throws Exception
   {loadData(1);
    String fname = "f1.txt";
    File g123 = new File(fname);
    if(g123.exists()) g123.delete();
    RandomAccessFile  f = new RandomAccessFile(fname, "rw"); 
    depth(1,f);
    f.writeBytes("\r\n");
    //-------------------------------------------------------------------------------------
     /*You must keep statements pre-given in this function.
       Your task is to insert statements here, just after this comment,
       to complete the question in the exam paper.*/
       depth2(1, f);

    //-------------------------------------------------------------------------------------
    f.writeBytes("\r\n");
    f.close();
   }
//===========================================================================
    public void Dijkstra(int from, int to,RandomAccessFile  f) throws IOException{
        boolean visited[] =new boolean[n];
        int d[] = new int[n];
        int path[] = new int[n];
        for (int i=0;i<n;i++){
            visited[i]=false;
            d[i]=999;
            path[i]=-1;
        }
        int sel = from;        
        d[sel]=0;
        path[sel]=from;
        for (int i=0;i<n;i++){
            
            visited[sel] = true;
            //calculate d[i] from sel
            for (int j=0;j<n;j++){
                if (!visited[j] && d[j]>d[sel]+a[sel][j]){
                    d[j] = d[sel]+a[sel][j];                    
                    path[j]=sel;
                }
            }
            //find min distance
            int min=999;
            for (int t = 0;t<n;t++){
                if (min>d[t] && !visited[t]){
                    sel = t;
                    min=d[t];
                }
            }
        }
        
        int x = to;     
        String line1=""  ,line2=  "";
        while (true){      
            line1=v[x]+" "+line1;
            line2=d[x] +" "+line2;
            if (x==from) break;
            x=path[x];
        }
//        System.out.println(line1);
//        System.out.println(line2);        
//        f.writeChars(line1 +"\n"+line2  );
        f.writeBytes(line1);
          f.writeBytes("\n");
          f.writeBytes(line2);
       
         
//        f.writeBytes(line2);
//        f.writeChars(line2.trim());
        
    }
  void f2() throws Exception
   {loadData(12);
    String fname = "f2.txt";
    File g123 = new File(fname);
    if(g123.exists()) g123.delete();
    RandomAccessFile  f = new RandomAccessFile(fname, "rw"); 
    //-------------------------------------------------------------------------------------
     /*You must keep statements pre-given in this function.
       Your task is to insert statements here, just after this comment,
       to complete the question in the exam paper.*/
//       System.out.println("");
//       f.writeBytes(fname);
        Dijkstra(0, 4, f);
    //-------------------------------------------------------------------------------------
    f.writeBytes("\r\n");
    f.close();
   }

//===========================================================================
/*
Algorithm for finding an Euler cycle from the vertex X using stack 
//Input: Connected graph G with all vertices having even degrees
//Output: Euler cycle
declare a stack S of characters
declare empty array E (which will contain Euler cycle)
push the vertex X to S
while(S is not empty)
 {r = top element of the stack S 
  if r is isolated then remove it from the stack and put it to E
   else
   select the first vertex Y (by alphabet order), which is adjacent
   to r, push  Y  to  S and remove the edge (r,Y) from the graph   
 }
 the last array E obtained is an Euler cycle of the graph
*/
  int isOlated(int v){
      for (int i=0;i<n;i++){
          if (a[v][i]>0) return i;
      }
      return -1;
  }
    public  void findEulerCycle(int v1,RandomAccessFile  f) throws IOException{
         ArrayList t = new ArrayList();
         Stack s = new Stack();
         int sel=v1;
         s.push(sel);
         while (!s.isEmpty()){
             int tmp = s.top() ;              
             sel=isOlated(tmp);
             if (sel==-1){//=> tmp la dinh co lap
                 tmp=s.pop();
                 t.add(tmp);
             }else{
                 //s ko la dinh co lap, check la dinh lien ke dau tien
                 //dua check vao stack va remoe canh tmp,check
                s.push(sel);
                a[tmp][sel]--;
                a[sel][tmp]--;               
             }             
         }
         for (int i=0;i<t.size();i++){
          f.writeBytes(" "+v[(int) t.get(i)]);
      }
          
        
    }
    public void display(){
        System.out.println("");
        for (int i=0;i<n;i++){
            for (int j=0;j<n;j++){
                System.out.print (a[i][j]+" ");
            }
            System.out.println("");
        }
        System.out.println("");
    }
    public ArrayList isEulerPath(){
        ArrayList lt = new ArrayList();
        loadData(20);
        int SUM=0;
        
        for (int i = 0; i < n; i++) {
            SUM=0;
            for (int j = 0; j < n; j++) {
                SUM+=a[i][j];
            }
            if (SUM%2==1) {
                lt.add(i);                 
            }   
        }         
         return lt;
    }
    public void findEulerPath(ArrayList lt){
       
    }
  void f3() throws Exception
   {loadData(20);
    String fname = "f3.txt";
    File g123 = new File(fname);
    if(g123.exists()) g123.delete();
    RandomAccessFile  f = new RandomAccessFile(fname, "rw"); 
    f.writeBytes("\r\n");
    //-------------------------------------------------------------------------------------
     /*You must keep statements pre-given in this function.
       Your task is to insert statements here, just after this comment,
       to complete the question in the exam paper.*/
      // You can use the statement fvisit(i,f); i = 0, 1, 2,...,n-1 to display the vertex i to file f5.txt 
      //  and statement f.writeBytes(" " + k); to write  variable k to the file f5.txt  
//      for (int i=0;i<n;i++) fvisit(i, f);
      findEulerCycle(2,f);      
      


    //-------------------------------------------------------------------------------------
    f.writeBytes("\r\n");
    f.close();
   }

}
//=================================================================
// public void dijkstra(int from, int to) {
//        int distance[] = new int[n];
//        boolean[] visited = new boolean[n];
//        int[] path = new int[n];
//        for (int i = 0; i < n; i++) {
//            distance[i] = Integer.MAX_VALUE;
//            path[i] = from;
//            visited[i] = false;
//        }
//
//        System.out.println("");
//        distance[from] = 0;
//        int sel = from;
//        visited[sel] = true;
////        path[0] = from;
//        for (int t = 0; t < n; t++) {
//            
//            for (int i = 0; i < n; i++) {
//                //cac dinh lien ke cua from
//                if (!visited[i] && (adj[sel][i] + distance[sel] < distance[i])) {
//                    distance[i] = adj[sel][i] + distance[sel];
//                    path[i]=sel;
//                }
//
//            }
//            int min = Integer.MAX_VALUE;          
//            for (int i = 0; i < n; i++) {
//                if (!visited[i] && (distance[i] < min ) ) {
//                    sel = i;
//                    min = distance[i];
//                }
//            }
//            visited[sel] = true;
//        }
//
//       
//        int x =to;
//        Stack stack = new Stack();
//        while (x!=from){
//            stack.push(x);            
//             x=path[x];
//        }
//        stack.push(from);
//        while (!stack.isEmpty()){
//            x = (int) stack.pop();
//            System.out.print (Vertex [x]+" ");
//        }
//        System.out.println("distance = "+distance[to]);
//
//    }
